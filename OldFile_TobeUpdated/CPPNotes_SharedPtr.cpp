#include<iostream>
#include<string>
#include<memory>
using namespace std;
/* 1. C++ 11: Compiler generated function */
/*
* C++ 03:
* 1. Default Constructor (generated only if no constructor is declared by the user)
* 2. Copy Constructor (C++ 11: generated only if no 3, 4, 5, 6 is declared by the user)
* 3. Copy Assignment Operator (C++ 11:generated only if no 2, 4, 5, 6 is declared by the user)
* 4. Destructor 
*
* C++ 11:
* 5. Move Constructor (C++ 11: generated only if no 2, 3, 4, 6 is declared by the user)
* 6. Move Assignment Operator (C++ 11: generated only if no 2, 3, 4, 5 is declared by the user)
 */
class dog {}; //1, 2, 3, 4, 5, 6 will be generated by the compiler
//is euqivalent to:
class dog{
    //C++ 03:
    dog();
    dog(const dog& d);
    dog& operator=(const dog& d);
    ~dog();
    //c++ 11:
    dog(const dog&& d);
    dog& operator=(dog&& d);
};

class cat{ //3, 4 will be generated by compiler. (3 is deprecated)
    cat(const cat& c); //copy constructor. 
};

class Duck{ // 4 will be generated by compiler
    Duck(Duck&& d); //Move constructor
};

class Frog{ // 4 ...
    Frog(Frog&& f, int x = 0);//Move constructor
    Frog(int x = 0); //Default constructor
    Frog(Frog& f, int x = 0) //Copy Constructor
};

class Fish{ // 1, 2, 3 ... (2, 3 are deprecated)
    ~Fish(); //Destructor
};

class Cow{ // 1, 2, 4 ... (2 is deprecated. Still there, should not use it according to the above rule. Explicit define 2 if we want to use it.)
    Cow& operator=(const Cow& C) = delete; // Still count as copy assignment operator declared by the user
};



/* 2. C++ 11: Shared pointer */
class Dog{
    string m_name;
    public:
    Dog(string name){cout << "Dog is created: "<< name <<endl; m_name = name;}
    Dog(){cout << "Nameless dog created. " << name <<endl; m_nam = "nameless";}
    ~Dog(){cout << "Dog is destroyed: " << m_name <<endl;}
    void bark(){cout << "Dog " << m_name << "rules!" << endl;}
};
//Hard to track when to delete pointer in large project
void foo(){
    Dog* p = new Dog("Gunner");
    //...
    delete p;
    //...
    p->bark(); // p is a dangling pointer now -- undefined behavior
}// If we do not delete p, then we will have memory leak

void fooFunc(){
    //We will have a count to keep track of how many pointers are pointing to the object.
    shared_ptr<Dog> p(new Dog("Gunner")); // count == 1 now

    //This is not allowed
    //shared_ptr<Dog> pt = new Dog("Smile");

    //Returns the raw pointer. 
    //In general, avoid using raw pointer when use smart pointers
    Dog* ptr = p.get(); 

    //We can dereference the smart pointer just like the raw pointer
    (*p).bark();
    //Use the shared pointer just like the raw pointer.
    p->bark();

    {
        shared_ptr<Dog> p2 = p; //count == 2
        p2->bark();
        cout << p.use_count() << endl; //Output how many pointers we have
    }
    p->bark(); //count == 1

}// count will be 0 when code executes to here, and Gunner will be deleted

void foo_01Func(){
    Dog* d = new Dog("Tank"); //Should not use
    shared_ptr<Dog> p(d); // p.get_count() == 1
    //Here when p goes out of scope, d will be destroyed. 
    //Then p2 goes out of scope, p2 will be destroyed again...
    shared_ptr<Dog> p2(d); // p2.get_count() == 1, the counter won't increase

    /* Lesson: An object should be assigned to a shrared_pointer 
    immediately when it is created. The above case does not follow 
    this rule. We first create the raw pointer d and then initialize 
    p and p2 with d. We should do somthing like: 
    shared_ptr<Dog> p(new Dog("Tank")), then shared_ptr<Dog> p2 = p.*/

}

void booFunc(){
    //Another way to create a shared pointer:
    //Faster and safer/ Exception safe
    shared_ptr<Dog> p = make_shared<Dog>("Thank"); 

    shared_ptr<Dog> p1 = make_shared<Dog>("Gunner");
    shared_ptr<Dog> p2 = make_shared<Dog>("Tank");
    // In the following situation, Gunner is deleted
    p1 = p2; 
    //p1 = nullptr; 
    //p1.reset();

    //Sometimes we have to use constructor to create shared pointer 
    //instead of make_shared<class>(). We will take a look at below:
    //using default deleter: operator delete
    shared_ptr<Dog> p3 = make_shared<Dog>("Shooter"); 

    //Define our own custome deleter
    shared_ptr<Dog> p4 = shared_ptr<Dog>(new Dog("Tank"), [](Dog* p){cout << "Custome deleting."; delete p;}); 
    
    //Dog[1] and Dog[2] have memory leak.
    shared_ptr<Dog> p5(new Dog[3]);
    //All 3 dogs will be deleted when p goes out of scope 
    shared_ptr<Dog> p6(new Dog[3], [](Dog* p){delete[] p;}); 
}

int main(){
    fooFunc();

    //The following function can also work on shared pointers
    // static_pointer_cast
    // dynamic_pointer_cast
    // const_pointer_cast
    return 0;
}







